/**
 * @file layers.h
 * @brief Prototypes for layers.
 *
 * @author misaka-10032 (longqic@andrew.cmu.edu)
 */

#ifndef HALSTM_LAYERS_H
#define HALSTM_LAYERS_H

#include <Halide.h>
#include <maths.h>
#include <vector>
#include <string>
#include <vector>
#include "activation.h"

using namespace Halide;

class Layer {
public:

  virtual void forward(Func& in, Func& out);
  virtual void backward(Func& in, Func& out);
};

template  <typename T>
class LSTMLayer: public Layer{
public:
  int I_; // input dimension
  int H_; // num of hidden units;
  int T_; // length of sequence
  int N_; // batch size

  // parameters
  Image<T> weight_i_;    // (4*H x I)
  Image<T> weight_h_;    // (4*H x H)
  Image<T> bias_;        // (1 x 4*H)
  Image<T>  bias_multiplier_;  // (T x N x 1)

  std::vector<Image<T>> top_;
  std::vector<Image<T>> cell_;

  Image<T> c_0_; // previous cell state value         (N x H)
  Image<T> h_0_; // previous hidden activation value  (N x H)
  Image<T> c_T_; // next cell state value             (N x H)
  Image<T> h_T_; // next hidden activation value      (N x H)


  LSTMLayer(int t, int H, int I, int N):
          T_(t), H_(H), I_(I), N_(N){

    // Initialize space to store each hidden unit's result
    top_ = std::vector<Image<T>>(T_, Image<T>());
    cell_ = std::vector<Image<T>>(T_, Image<T>());
  }

  void forward(Func& bottom, Func & out){
    Var i, j, k;

    bool clip;    //TODO: figure out what is this

    // load parameters from memory
    Func bias_multiplier("bias_multiplier");
    bias_multiplier(i, j, k) = bias_multiplier_(i, j, k);  // (T x N x 1)
    Func weight_i("weight_i");
    weight_i(i, j) = weight_i_(i, j);
    Func weight_h("weight_h");
    weight_h(i, j) = weight_h_(i, j);
    Func bias("bias");
    bias(i, j) = bias_(i, j);

    // compute input to hidden forward propagation
    Func pre_gate_data("pre_gate_data");
    pre_gate_data = halstm::matrix_dot(true, false, false, true, bottom, weight_i, N_, 4*H_, I_);
    Func multiplied_bias;
    multiplied_bias = halstm::matrix_dot(true, false, false, false, bias_multiplier, bias, N_, 4*H_, 1);
    pre_gate_data = halstm::matrix_add(true, pre_gate_data, multiplied_bias, N_, 4*H_);

    for (int t = 0; t < T_; t++){

      // Load last hidden unit's result
      Func h_t_1("h_t_1");
      Func c_t_1("c_t_1");
      if (t > 0){
        // load last hidden unit's result: cell state and output
        Func top_data("top_data");
        top_data(i, j) = (top_[t-1])(i, j);
        Func cell_data("cell_data");
        cell_data(i, j, k) = (cell_[t-1](i, j));
        h_t_1(i, j) = top_data(i, j);
        c_t_1(i, j) = cell_data(i, j);
      }else if (t == 0){
        // initially, initialized with historical or default result
        Func c_0 ("c_0_");
        Func h_0 ("h_0_");
        if (clip) {
          c_0(i, j) = c_T_(i, j);
          h_0(i, j) = h_T_(i, j);
        }else{
          c_0(i, j) = c_0_(i, j);
          h_0(i, j) = h_0_(i, j);
        }
        h_t_1(i, j) = h_0(i, j);
        c_t_1(i, j) = c_0(i, j);
      }

      // to store final result from this unit
      Func h_t("h_t");
      Func c_t("c_t");

      // to store values generated by 4 gates
      Func gate_t[4];

      // input-to-hidden propagation
      Func pre_gate_t("pre_gate_t");
      pre_gate_t(i, j) = pre_gate_data(i, j, t);

      // hidden-to-hidden propagation
      Func h_to_gate("h_to_gate");
      h_to_gate = halstm::matrix_dot(false, false, false, true, h_t_1, weight_h, N_, 4*H_, H_);

      // combine hidden input and last layer input
      pre_gate_t = halstm::matrix_add(false, h_to_gate, pre_gate_t, N_, 4*H_);

      //apply nonlinearty
      RDom gates_range(0, H_, H_, 2*H_, 2*H_, 3*H_, 3*H_, 4*H_);
      Func pre_gate_t0("pre_gate_t0");
      pre_gate_t0(i, j) = pre_gate_t(gates_range.x, j);
      gate_t[0](i, j) = (halstm::Sigmoid_(pre_gate_t0))(i, j);
      Func pre_gate_t1("pre_gate_t1");
      pre_gate_t1(i, j) = pre_gate_t(gates_range.y, j);
      gate_t[1](i, j) = (halstm::Sigmoid_(pre_gate_t1))(i, j);
      Func pre_gate_t2("pre_gate_t2");
      pre_gate_t2(i, j) = pre_gate_t(gates_range.z, j);
      gate_t[2](i, j) = (halstm::Sigmoid_(pre_gate_t2))(i, j);
      Func pre_gate_t3("pre_gate_t3");
      pre_gate_t3(i, j) = pre_gate_t(gates_range.w, j);
      gate_t[3](i, j) = (halstm::Tanh_(pre_gate_t3))(i, j);

      Func forget_gate; forget_gate(i, j) = halstm::matrix_mul(gate_t[1], c_t_1);
      Func input_gate;  input_gate(i, j) = halstm::matrix_mul(gate_t[0], gate_t[3]);
      c_t(i, j) = halstm::matrix_add(false, forget_gate, input_gate, N_, H_);
      Func filter_gate;  filter_gate(i, j) = halstm::Tanh_(c_t);
      h_t(i, j) = halstm::matrix_mul(filter_gate, gate_t[2]);   //N_, H_

      //TODO: potential runtime error, figure out how to aggregate #T results
      out(i, j, t) = h_t(i, j);

      //store this hidden unit's output
      h_t.realize(top_[t]);
      c_t.realize(cell_[t]);
    }
  }
};

#endif // HALSTM_LAYERS_H
